// LinkedList.h

// tom bailey   0740  5 oct 2010
// Declaration of the List class.

// A List stores and manages a sequence of doubles.

// This version uses a pointer to the first Node of a
//   singly linked list of Nodes.


#ifndef _LINKED_LIST_H_
#define _LINKED_LIST_H_

#include <iostream>
using std::ostream;

class Node
{
public:
	double entry_;
	Node * next_;

public:
	// Constructors

	// post: this Node contains entry and a NULL pointer
	explicit Node(double entry);

	// post: this Node contains entry and next
	Node(double entry, Node * next);

	// Destructor

	~Node();

private:
	// Inaccessible standard functions
	Node();
	Node(const Node &);
	const Node & operator=(const Node &);
};

Node::Node(double entry)
	: entry_(entry), next_(NULL){}

Node::Node(double entry, Node * next)
	: entry_(entry), next_(next){}

Node::~Node(){}

#define ulong unsigned long


class List
{
public:
	//*** Standard functions ***

	// Default constructor
	// post: this List is empty.
	List();

	// Destructor
	// post: all the Nodes of this List have been destroyed.
	~List();

	// Assignment operator
	// post: this List now stores a copy of the sequence stored
	//         in other
	const List & operator=(const List & other);

	// post: true has been returned just if this List is
	//         empty.
	bool empty() const;

	//*** Mutators ***

	// post: x has been added as the first double in this
	//         List.
	void insertAsFirst(double x);

	// pre:  this List is not empty.
	// post: the first double in this List has been removed
	//         from this List and has been returned.
	double removeFirst();

	void insertAsLast(double x);

private:
	Node * first_;

};

List::List()
	: first_(NULL)
{
}

List::~List()
{
	while (!empty())
	{
		removeFirst();
	}
}

bool List::empty() const
{
	return first_ == NULL;
}


void List::insertAsFirst(double x)
{
	first_ = new Node(x, first_);
}


double List::removeFirst()
{
	double item = first_->entry_;
	Node * tempPtr = first_;
	first_ = first_->next_;
	delete tempPtr;
	return item;
}

void List::insertAsLast(double x)
{
	if (!empty())
	{
		Node * ptr = first_;
		while (ptr != NULL)
		{
			if (ptr->next_ == NULL)
			{
				ptr->next_ = new Node(x);
				break;
			}
			else { ptr = ptr->next_; }
		}
	}
	else { insertAsFirst(x); }
}

#endif
